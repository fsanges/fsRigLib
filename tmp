import maya.mel as mel
from kmd.lib import transform
import maya.cmds as mc
import string
import maya.OpenMaya as om
import pymel.core as pm
# _import shape module
# import controlCurveShapes as ccs
from kmd.lib.ctrl import ctrl_gen as ctgen;
reload(ctgen)
from kmd.lib import defaults;
reload(defaults)
from kmd.lib import names as nm;
reload(nm)
from kmd.lib import skin as skin;
reload(skin)
from kmd.lib import transform as trs;
reload(trs)
from kmd.lib import deformer;
reload(deformer)
from kmd.lib.defaults import Suffix as sfx;
from kmd.lib import matrix_spline


LETTERS = string.ascii_uppercase
# letnum = defaults.Defaults_Alphabet().index_numbers_letters
# index_colors = defaults.Defaults_Shapes().index_colors



class MatrixRibbon(object):
    def __init__(self):
        self.name = 'ribbon'
        self.num_layers = 3
        self.lyr_density_u = (1, 2, 6, 16)
        self.lyr_density_v = (1, 1, 1, 1, 1)
        self.blendShape = False
        self.scale = 1.00
        self.edge_at_origin = True
        self.driven_surface = True
        self.width = 10.0
        self.height = 10.0
        self.one_dimension = True
        self.auto_ctrl_curves = True
        self.rotation_on = True
        self.direction = 'u'
        self.create_auto_mesh = True
        self.attach_shapes = True
        self.matrix_output = False
        self.global_scale = False
        self.add_custom_lyr = 0
        self.axis = (0, 1, 0)
        self.vertical = (0, 1, 0)
        self.align_with_grid = False
        self.offset = (0, 0, 0)
        self.curve_ribbon = False
        self.plane_ribbon = False
        self.length_ratio = 1.0
        self.out_curve = False
        self.degree = 2

        # main variables
        self.driver_surface_list = list()
        self.smooth_skin_mesh_list = list()
        self.layer_geos = list()
        self.jnt_layers_list = list()
        self.last_pos_list = list()
        self.last_transform_list = list()
        self.delete_list = list()
        self.bind_joint_list = list()
        self.curves_loc_lists = list()

        self.return_dict = dict()
        self.custom_lyr_dict = dict()
        self.jnt_loc_dict = dict()

        self.top_grp = "{}_rig{}".format(self.name, sfx.group)
        self.driver_surfaces_grp = '{}_driver{}{}'.format(self.name, sfx.nurbsSurface, sfx.group)
        self.base_plane = '{}_source{}'.format(self.name, sfx.nurbsSurface)

        self.ctrl_grp = ""
        self.scale_locs_grp = ""
        self.output_curve = ""

        # Curve ribbon
        self.driver_curve_list = list()
        self.driver_plane_list = list()


    def initial_build(self):
        '''Basic grps'''
        delete_list = list()
        # Create basic grps
        if mc.objExists(self.top_grp):
            mc.delete(self.top_grp)
            # TODO : Add rebuild select option
        self.top_grp = mc.createNode('transform', n=self.top_grp)

        # Create connection top grp
        self.driver_surfaces_grp = mc.createNode('transform', n=self.driver_surfaces_grp)
        mc.setAttr(self.driver_surfaces_grp + '.v', 0, lock=True)

        # create linear plane
        self.base_plane = mc.nurbsPlane(
            p=(0, 0, 0),
            ax=self.axis,
            width=self.width,
            lengthRatio=self.length_ratio,
            d=1,
            u=1,
            v=1,
            ch=0,
            n=self.base_plane)[0]

        # Use the grid cordinates to place the ribbon in space. Ex. Slide plane so the edge is the origin of the world
        if self.align_with_grid:  # TODO : add if - to check : self.align_with_grid = True

            mc.move(0, 0, 0, self.base_plane + '.cv[0][0]', worldSpace=True)
            mc.move(self.height, 0, 0, self.base_plane + '.cv[1][0]', worldSpace=True)
            mc.move(0, 0, self.width, self.base_plane + '.cv[0][1]', worldSpace=True)
            mc.move(self.height, 0, self.width, self.base_plane + '.cv[1][1]', worldSpace=True)

        # use other rotate option from ctgen
        if self.vertical:
            ctgen.change_object_orientation(passed_object=self.base_plane, orientation=self.vertical, offset=self.offset)

        if self.direction == 'v':
            mc.reverseSurface(self.base_plane, d=3, ch=0, rpo=1)
            # Swap u with v
            density_v = self.lyr_density_v
            self.lyr_density_v = self.lyr_density_u
            self.lyr_density_u = density_v

        # RUN function to create a plane for each layer with the correct resolution
        self.layer_geos, surf_grp = self.create_plane_resolution_for_each_layer()
        delete_list.append(surf_grp)

        # We'll use the last layer, the surface with most subdivisions, as the template for all final surfaces.
        # Create final surfaces layer and set the self.driver_surface_list
        self.create_driver_surfaces(self.layer_geos[-1])

        # Create base surface
        base_surf = mc.duplicate(self.driver_surface_list[0], n='{}_base{}'.format(self.name, sfx.nurbsSurface))[0]
        delete_list.append(base_surf)


        # add follicles to every layer
        follicles_dict = self.add_follicles_to_all(
            skin_bind=True,
            suffix='')

        self.jnt_layers_list = follicles_dict["all_list_of_ctrls_list"]
        self.all_follicles = follicles_dict["all_follicles"]
        self.ctrl_grp = follicles_dict["fol_top_grp"]
        # Check if we should build a custom layer with variable number of joints
        if self.add_custom_lyr:
            self.create_custom_lyr(jnt_layers_list, base_surf)

        # Setup position locators for each final point
        self.set_position_locs()

        # Create input global scale locator
        if self.global_scale:
            self.create_global_scale()

        mc.warning("before loop x")
        hub_lyr_list = list()
        mmx_lists = list()
        layers_weight_list = list()

        for x in range(0, self.num_layers):
            # Get vars
            driver_surf = self.layer_geos[x]
            # last_surface = self.layer_geos[-1]
            cur_surf = self.driver_surface_list[x]
            bind_js = self.jnt_layers_list[x]
            last_joints = self.jnt_layers_list[-1]
            LETTER = LETTERS[x]
            name = "{}_{}".format(self.name, LETTER)

            if x == self.num_layers - 1:
                next_surf = self.driver_surface_list[x]
                w2s_geometry, weight_list = self.set_last_layer(cur_surf, bind_js, name=name)#
                # mmx_lists.append(matrix_nodes_list)
                self.smooth_skin_mesh_list.append(w2s_geometry)
                layers_weight_list.append(weight_list)
                continue
            else:
                next_surf = self.driver_surface_list[x + 1]
            # Do it for a single line of joints (most of the time it's the one)
            if self.one_dimension:
                w2s_geometry, weight_list = self.set_one_d_ribbon(driver_surf, bind_js, next_surf, name=name)
                # mmx_lists.append(wam_list)
                self.smooth_skin_mesh_list.append(w2s_geometry)
                layers_weight_list.append(weight_list)
            else:
                w2s_geometry, weight_list = self.setup_plane_ribbon(driver_surf, bind_js, next_surf)
                # mmx_lists.append(wam_list)
                self.smooth_skin_mesh_list.append(w2s_geometry)
                layers_weight_list.append(weight_list)



        # setup blend shape chain
        if self.blendShape:
            self.setup_blend_shape_chain()
            # use locators as controls instead of joints
            self.create_joint_to_loc()

        # Setup Scale
        # self.layered_scale_setup2(layers_weight_list)
        # Create bind joints
        self.create_bind_joints()

        # replace surfaces with curves if true
        if self.curve_ribbon:
            self.curve_ribbon_setup()
            
        # replace surfaces with curves if true
        if self.plane_ribbon:
            self.plane_ribbon_setup()

        # Setup global scale
        self.create_global_scale()

        self.visual_reference(self.smooth_skin_mesh_list[-1])

        self.return_dict.update({
            "top_grp":self.top_grp,
            "ctrl_grp":follicles_dict["fol_top_grp"],
            "ctrls_lists":self.jnt_layers_list,
            "surface_list":self.driver_surface_list,
            "smooth_skin_meshes":self.smooth_skin_mesh_list,
            "driver_surfaces_grp":self.driver_surfaces_grp
            # "linear_ctrls":ctrls_bind
        })


        # Cleanup
        mc.delete(delete_list)
        self.cleanup()
        self.add_ctrl_shapes_to_ribbon(self.jnt_layers_list, ctrl_scale=.10)
        # lock and hide locs shapes
        for i, locs in enumerate(self.jnt_layers_list):lock_and_hide_loc_shapes(locs)
        lock_and_hide_loc_shapes(self.last_transform_list)


    def set_new_shape(self, new_shape_srf):
        new_shape = mc.listRelatives(new_shape_srf, s=1)[0]
        for i, srf in enumerate(self.driver_surface_list):
            # obj = mc.ls(selection=True)[0]
            orig = get_valid_orig_shape(srf)
            mc.connectAttr(new_shape + ".worldSpace[0]",
                           orig + ".create")
            mc.refresh()
            mc.disconnectAttr(new_shape + ".worldSpace[0]",
                              orig + ".create")
            try:
                skin = mc.ls(mc.listHistory(self.driver_surface_list[1+i], pdo=True),type='skinCluster')
                if skin:
                    mc.setAttr(skin[0] + ".envelope", 0)
                mc.refresh()
                reset_skin_cluster([self.driver_surface_list[1+i]])
                mc.refresh()
                # mc.setAttr(skin + ".envelope", 1)
            except:
                mc.warning("no surface on index : " + str(i))
        for i, srf in enumerate(self.driver_surface_list):
            try:
                mc.refresh()
                mc.disconnectAttr(new_shape + ".worldSpace[0]",
                                  orig + ".create")
                skin = mc.ls(mc.listHistory(self.driver_surface_list[1+i], pdo=True),type='skinCluster')
                mc.setAttr(skin[0] + ".envelope", 1)
            except:
                mc.warning("no surface on index : " + str(i))


    def setup_blend_shape_chain(self):
        ctrls_bind = []
        for x in range(0, self.num_layers - 1):
            # Get vars
            driver_surf = self.layer_geos[x]
            cur_surf = self.driver_surface_list[x]
            next_surf = self.driver_surface_list[x + 1]
            bind_js = self.jnt_layers_list[x]
            # create blendshape to next surf
            blnd = mc.blendShape(
                                cur_surf,
                                next_surf,
                                frontOfChain=True,
                                n='layer_%s_blnd' % LETTERS[x]
                                )[0]

            targets = mc.listAttr(blnd + '.w', m=1)
            mc.setAttr(blnd + '.' + targets[0], 1, lock=1)

            # Connect prebindMatrix
            mc.select('%s.cv[*:*]' % (next_surf), r=1)
            cvs = mc.ls(sl=1, fl=1)

            out_skin = skin.get_skin_cluster(next_surf)

            if out_skin:
                for i in range(len(bind_js)):
                    if mc.attributeQuery('parentMatrixPath', node=bind_js[i], exists=True):
                        mtx_jnt = mc.listConnections(bind_js[i] + '.parentMatrixPath')
                        mc.connectAttr('%s.parentInverseMatrix' % mtx_jnt[0], out_skin + '.bindPreMatrix[%d]' % i)
                    else:
                        mc.connectAttr('%s.parentInverseMatrix' % bind_js[i], out_skin + '.bindPreMatrix[%d]' % i)

    # # Cleanup a bit
    # mc.parent(base_surf, driver_surfaces_grp)
    # mc.parent(driver_surfaces_grp, follicles_dict["fol_top_grp"], top_grp)

    def cleanup(self):
        mc.parent(self.driver_surfaces_grp,
                  self.ctrl_grp,
                  self.scale_locs_grp,
                  self.top_grp)

        # Delete poly wire to skin meshes / Could be useful to recalculate the weights after building
        mc.delete(self.return_dict["smooth_skin_meshes"])

        mc.delete(self.base_plane)

        # Swap controls name if locators are the new controls
        if self.blendShape:
            self.rename_ctrl_and_jnts()

        if self.curve_ribbon:
            # delete surfaces trash
            mc.delete(self.driver_surfaces_grp, self.ctrl_grp)


    def set_blendShape(self, blendShape):
        self.blendShape = blendShape

    def set_align_with_grid(self, align):
        self.align_with_grid = align

    def set_height(self, height):
        self.height = height

    def set_width(self, width):
        self.width = width

    def set_vertical_axis(self, vertical):
        self.vertical = vertical


    def set_name(self, name):
        self.name = name
        self.top_grp = "{}_rig_{}".format(self.name, sfx.group)
        self.driver_surfaces_grp = '{}_driver_{}_{}'.format(self.name, sfx.nurbsSurface, sfx.group)
        self.base_plane = '{}_source_{}'.format(self.name, sfx.nurbsSurface)

    def set_curve_ribbon(self, bol):
        self.curve_ribbon = bol

    def set_plane_ribbon(self, bol):
        self.plane_ribbon = bol

    def get_name(self):
        return self.name

    def set_num_layers(self, num_layers):
        self.num_layers = num_layers

    def get_num_layers(self):
        return self.num_layers

    def set_lyr_density_u(self, lyr_density_u):
        self.lyr_density_u = lyr_density_u

    def get_lyr_density_u(self):
        return self.lyr_density_u

    def set_lyr_density_v(self, lyr_density_v):
        self.lyr_density_v = lyr_density_v

    def get_lyr_density_v(self):
        return self.lyr_density_v

    def set_on_dimention(self, value):
        self.one_dimension = value

    def get_return_dict(self):
        return self.return_dict


    def get_all_ctrls(self):
        ctrls_bind = []
        for x in range(0, self.num_layers - 1):
            # Get vars
            bind_js = self.jnt_layers_list[x]
            for each in bind_js:
                ctrls_bind.append(each)
        return ctrls_bind


    # Start functions
    def weights_from_wrap(self, driver_surf, cur_surf, next_surf, bind_js):
        # Use wrap in case it's a 2d ribbon
        wrapped = mc.duplicate(cur_surf, n=cur_surf + '_TMP')[0]

        mc.select(wrapped, driver_surf, r=True)
        mel.eval('CreateWrap ;')

        cvs = mc.ls(wrapped + '.cv[*][*]', fl=1)

        # Calculate weights
        all_displacement = list()
        for j in bind_js:

            pos = mc.xform(j, q=1, ws=1, rp=1)

            displacement = list()
            for v in cvs:
                # get initial pos
                ini_pos = mc.pointPosition(v, world=1)

                # get deformed pos
                mc.move(0, -1, 0, j, relative=1)
                def_pos = mc.pointPosition(v, world=1)

                # get distance between them
                ini_pos_v = om.MVector(ini_pos[0], ini_pos[1], ini_pos[2])
                def_pos_v = om.MVector(def_pos[0], def_pos[1], def_pos[2])

                result_v = def_pos_v - ini_pos_v

                length = result_v.length()
                displacement.append(length)

                mc.move(0, 1, 0, j, relative=1)

            all_displacement.append(displacement)

        mc.delete(wrapped)

        # skin ctrls on cur_surf
        out_skin = mc.skinCluster(
            bind_js,
            next_surf,
            dr=4.5,
            maximumInfluences=1,
            frontOfChain=0,
            toSelectedBones=1,
            n='out_mesh_skc'
        )

        # set weights
        for i, j in enumerate(bind_js):
            for y, dis in enumerate(all_displacement[i]):
                norm_value = dis
                mc.skinPercent(
                    out_skin[0],
                    next_surf + '.' + cvs[y].split('.')[1],
                    transformValue=[(j, norm_value)]
                )
                mc.setAttr(j + '.liw', 1)

        return out_skin

    def create_plane_resolution_for_each_layer(self, suffix=""):
        # return list with surf names
        layer_surfaces = []

        # Create sufaces parent
        surf_grp = mc.createNode('transform', n=self.name + '_surfaces_grp' + suffix)

        for layer_num in range(1, self.num_layers + 1):

            lyr_tag = LETTERS[layer_num - 1]

            # plane name and
            # surface = self.name + 'plane_' + lyr_tag + sfx.nurbsSurface + suffix
            # surface = mc.duplicate(self.base_plane, n=surface)[0]

            surface = mc.nurbsPlane(
                                    p=(0, 0, 0),
                                    ax=self.axis,
                                    width=self.width,
                                    lengthRatio=self.length_ratio,
                                    d=1,
                                    u=1,
                                    v=1,
                                    ch=0,
                                    n=self.name + 'plane_' + lyr_tag + sfx.nurbsSurface + suffix
                                    )[0]
            mc.delete(surface, ch=True)


            mc.parent(surface, surf_grp)
            layer_surfaces.append(surface)
            # Add message attr

            # num of spans
            spans_u = self.lyr_density_u[layer_num - 1]
            spans_v = self.lyr_density_v[layer_num - 1]

            # misc
            rebuild_type = 0
            degree_u = 1
            degree_v = 1

            # Create linear first to get the right spacing
            mc.rebuildSurface(
                surface,
                constructionHistory=0,
                replaceOriginal=1,
                rebuildType=rebuild_type,
                endKnots=1,
                keepRange=0,
                keepControlPoints=0,
                keepCorners=0,
                spansU=spans_u,
                degreeU=degree_u,
                spansV=spans_v,
                degreeV=degree_v,
                tolerance=0,
                fitRebuild=0,
                direction=2
            )


            # Rebuild it to quadratic maintaining cvs pos
            # Check if lyr A is linear
            if spans_u != 1:
                degree_u = 2
            if spans_v != 1:
                degree_v = 2

            mc.rebuildSurface(
                surface,
                constructionHistory=0,
                replaceOriginal=1,
                rebuildType=rebuild_type,
                endKnots=1,
                keepRange=0,
                keepControlPoints=1,
                keepCorners=0,
                spansU=spans_u,
                degreeU=degree_u,
                spansV=spans_v,
                degreeV=degree_v,
                tolerance=0,
                fitRebuild=0,
                direction=2
            )

        # mc.delete(self.base_plane)

        return (layer_surfaces, surf_grp)

    # All secondary functions

    # Get cv numbers into an unsable strig for all names
    def get_cv_col_row(self, cv):
        # get name colunms and rows from cv name
        cv_num = cv.split('.cv')[-1]
        cv_num = cv_num.split('][')
        # add col and row with padding
        row = cv_num[0][1:].rjust(2, '0')
        col = cv_num[1][:-1].rjust(2, '0')
        return [row, col]

    # Create layer with attributes connection.
    def connect_message_attr(self, lyr_grp, object, s_attribute_name):
        s_attribute_type = "message"

        if not isinstance(object, type(list())):
            mc.addAttr(
                object,
                longName=s_attribute_name,
                attributeType=s_attribute_type)
            # Connect default message attr from "layer" group node to
            mc.connectAttr(lyr_grp + '.message', object + '.' + s_attribute_name)
        else:
            for obj in object:
                # Attribute type
                # Add attr type message to object
                mc.addAttr(obj, longName=s_attribute_name,
                           attributeType=s_attribute_type)
                # Connect default message attr from "layer" group node to
                mc.connectAttr(lyr_grp + '.message', obj + '.' + s_attribute_name)

    def follicle_from_cvs(self,
                          prefix,
                          driven,
                          current_lyr_geo,
                          lyr_cvs,
                          tag,
                          ):

        cv_tag_num_list = []
        follicle_list = []

        for p in lyr_cvs:

            # get name colunms and rows from cv name function
            row_col = self.get_cv_col_row(p)

            name = prefix + 'layer_' + tag + '_' + row_col[0] + '_' + row_col[1]
            # if

            cv_tag_num_list.append(tag + '_' + row_col[0] + '_' + row_col[1])

            # Create follicle grp
            fol_p = prefix + 'follicles_' + tag + '_grp' + driven
            if not (mc.objExists(fol_p)):
                fol_p = mc.createNode('transform', n=fol_p)

            # Create follicle transform and shape
            fol = mc.createNode(
                'transform',
                n=name +
                  '_follicle_n' +
                  driven,
                p=fol_p)
            follicle_list.append(fol)
            fols = mc.createNode(
                'follicle',
                p=fol,
                n=name +
                  '_follicleShape' +
                  driven)
            # hide shape
            mc.setAttr(fols + '.v', 0, lock=True)

            # Connect to currentLyrGeo
            mc.connectAttr(
                current_lyr_geo +
                '.worldMatrix[0]',
                fols +
                '.inputWorldMatrix')
            mc.connectAttr(current_lyr_geo + '.local', fols + '.inputSurface')
            mc.connectAttr(fols + '.outTranslate', fol + '.translate')

            # connect rotation if needed
            if self.rotation_on:
                mc.connectAttr(fols + '.outRotate', fol + '.rotate')

            # Create loc on point
            pos = mc.xform(p, q=1, t=1, ws=1)
            loc = mc.spaceLocator(n='pos_loc')[0]
            mc.move(pos[0], pos[1], pos[2], loc, rpr=1)
            mc.parent(loc, current_lyr_geo)

            u_rng = mc.getAttr(current_lyr_geo + '.minMaxRangeU')
            v_rng = mc.getAttr(current_lyr_geo + '.minMaxRangeV')

            # Create node closestPointOnSurface
            point_surf = mc.createNode(
                'closestPointOnSurface',
                n='tmp_closestPointOnSurface_1')
            mc.connectAttr(
                current_lyr_geo + '.local',
                point_surf + '.inputSurface')
            mc.connectAttr(loc + '.translate', point_surf + '.inPosition')

            # Get uv coords
            u = mc.getAttr(point_surf + '.u')
            v = mc.getAttr(point_surf + '.v')

            # Normalized uv's then set follicle paramenters
            norm_u = abs(u / u_rng[0][1])
            norm_v = abs(v / v_rng[0][1])

            mc.setAttr(fols + '.parameterU', norm_u)
            mc.setAttr(fols + '.parameterV', norm_v)

            mc.delete(point_surf, loc)

        return (follicle_list, cv_tag_num_list, fol_p)

    def follicle_from_cvs_one_d(self,
                                prefix,
                                driven,
                                current_lyr_geo,
                                lyr_cvs,
                                tag,
                                ):
        cv_tag_num_list = []
        follicle_list = []

        for p in lyr_cvs:

            # get name colunms and rows from cv name function
            if self.direction == 'u':
                row_col = self.get_cv_col_row(p)
            else:
                tmp_row_col = self.get_cv_col_row(p)
                row_col = [tmp_row_col[1], tmp_row_col[0]]

            if row_col[1] == '00':
                name = prefix + 'layer_' + tag + '_' + row_col[0]

                cv_tag_num_list.append(tag + '_' + row_col[0])

                # Create follicle grp
                fol_p = prefix + 'follicles_' + tag + '_grp' + driven
                if not (mc.objExists(fol_p)):
                    fol_p = mc.createNode('transform', n=fol_p)

                # Create follicle transform and shape
                fol = mc.createNode(
                    'transform',
                    n=name +
                      '_follicle_n' +
                      driven,
                    p=fol_p)
                follicle_list.append(fol)
                fols = mc.createNode(
                    'follicle',
                    p=fol,
                    n=name +
                      '_follicleShape' +
                      driven)
                # hide shape
                mc.setAttr(fols + '.v', 0, lock=True)

                # Connect to current_lyr_geo
                mc.connectAttr(
                    current_lyr_geo + '.worldMatrix[0]',
                    fols + '.inputWorldMatrix')
                mc.connectAttr(current_lyr_geo + '.local', fols + '.inputSurface')
                mc.connectAttr(fols + '.outTranslate', fol + '.translate')

                # connect rotation if needed
                if self.rotation_on:
                    mc.connectAttr(fols + '.outRotate', fol + '.rotate')

                # Create loc on point
                pos = mc.xform(p, q=1, t=1, ws=1)
                loc = mc.spaceLocator(n='pos_loc')[0]
                mc.move(pos[0], pos[1], pos[2], loc, rpr=1)
                mc.parent(loc, current_lyr_geo)

                u_rng = mc.getAttr(current_lyr_geo + '.minMaxRangeU')
                v_rng = mc.getAttr(current_lyr_geo + '.minMaxRangeV')

                # Create node closestPointOnSurface
                point_surf = mc.createNode(
                    'closestPointOnSurface',
                    n='tmp_closestPointOnSurface_1')
                mc.connectAttr(
                    current_lyr_geo + '.local',
                    point_surf + '.inputSurface')
                mc.connectAttr(loc + '.translate', point_surf + '.inPosition')

                # Get uv coords
                u = mc.getAttr(point_surf + '.u')
                v = mc.getAttr(point_surf + '.v')

                # Normalized uv's then set follicle paramenters
                norm_u = abs(u / u_rng[0][1])
                norm_v = abs(v / v_rng[0][1])

                if self.direction == 'v':
                    mc.setAttr(fols + '.parameterV', norm_v)
                    mc.setAttr(fols + '.parameterU', .5)
                else:
                    mc.setAttr(fols + '.parameterU', norm_u)
                    mc.setAttr(fols + '.parameterV', .5)

                mc.delete(point_surf, loc)

        return (follicle_list, cv_tag_num_list, fol_p)

    def joint_to_follicle(self,
                          prefix,
                          driven,
                          follicle_list,
                          tag,
                          radius,
                          lyrTag
                          ):

        joint_list = []
        x = 0
        for s in follicle_list:
            # name = prefix + 'lyr_' + tag[x] + '_ctrl' + driven
            name = prefix + tag[x] + '_ctrl' + driven
            x = x + 1
            mc.select(cl=1)
            j = mc.joint(n=name, radius=radius)
            joint_list.append(j)

            mc.select(cl=1)
            mc.parent(j, s)
            mc.setAttr(j + '.tx', 0)
            mc.setAttr(j + '.ty', 0)
            mc.setAttr(j + '.tz', 0)

            mc.setAttr(j + '.jointOrientX', 0)
            mc.setAttr(j + '.jointOrientY', 0)
            mc.setAttr(j + '.jointOrientZ', 0)

        return joint_list

    # Loop thru every surface to add follicles

    # Loop thru every surface to add follicles
    def add_follicles_to_all(self, skin_bind=True, suffix=""):

        # _t_e_s_t for loop
        all_follicles = []
        cv_tag_num = []
        radius = .7
        all_lyr_joint_list = []
        follicle_grp_list = []
        all_list_of_ctrls_list = []

        # follicles top grp
        fol_top_grp = mc.createNode(
            'transform',
            n=self.name + 'follicles_top_grp' + suffix)

        for i in range(0, self.num_layers):

            # _test if it's not the last surface, if it is break
            '''if i == self.num_layers-1:
                mc.warning('_breaking _h_e_r_e : ' + self.layer_geos[i])
                break'''

            # get current layer surface
            current_lyr_geo = self.driver_surface_list[i]
            next_lyr_geo = self.layer_geos[i]

            # get points from next surface
            lyr_cvs = mc.ls(next_lyr_geo + '.cv[*][*]', fl=1)

            # get _tag
            lyr_tag = LETTERS[i]

            # _run follicle_from_cvs function to create the follicles

            if self.one_dimension:
                follicles_list, cv_name_list, fol_p = self.follicle_from_cvs_one_d(
                    self.name, suffix, current_lyr_geo, lyr_cvs, lyr_tag)
                mc.parent(fol_p, fol_top_grp)
                follicle_grp_list.append(fol_p)

                all_follicles.append(follicles_list)
                cv_tag_num.append(cv_name_list)

            else:
                follicles_list, cv_name_list, fol_p = self.follicle_from_cvs(
                    self.name, suffix, current_lyr_geo, lyr_cvs, lyr_tag)
                mc.parent(fol_p, fol_top_grp)

                follicle_grp_list.append(fol_p)

                all_follicles.append(follicles_list)
                cv_tag_num.append(cv_name_list)

                # _create joint in each follicle
            lyr_joint_list = self.joint_to_follicle(
                self.name,
                suffix,
                follicles_list,
                cv_name_list,
                radius,
                lyr_tag
            )
            all_lyr_joint_list.extend(lyr_joint_list)
            all_list_of_ctrls_list.append(lyr_joint_list)

            radius = radius / 1.7

            # bind
            if skin_bind:
                skin = mc.skinCluster(
                    lyr_joint_list,
                    next_lyr_geo,
                    dr=4.5,
                    maximumInfluences=1,
                    frontOfChain=1,
                    toSelectedBones=1,
                    n=self.name +
                      'layer_' +
                      lyr_tag +
                      '_sk_c')

        return {
            "all_follicles": all_follicles,
            "cv_tag_num": cv_tag_num,
            "all_lyr_joint_list": all_lyr_joint_list,
            "fol_top_grp": fol_top_grp,
            "follicle_grp_list": follicle_grp_list,
            "all_list_of_ctrls_list": all_list_of_ctrls_list
        }

    def add_extra_custom_layer(self, in_surface, in_bind_joints):
        """
        Creates a duplicate of the surface, skin's it and attaches a variable numbers of controls

        """
        # get out_surface
        out_surf = mc.duplicate(in_surface, n="{}_multi_layer_srf".format(in_surface))[0]
        # Clean surf function

        # bind
        skin = mc.skinCluster(
            in_bind_joints,
            out_surf,
            dr=4.5,
            maximumInfluences=1,
            frontOfChain=0,
            toSelectedBones=1,
            n=out_surf + '_skc')[0]

        return out_surf

    def add_follicles_to_custom_lyr(self, in_surface,
                                    num_of_joints=20,
                                    name=''
                                    ):

        rebuilt_curve, cvs_curve = duplicate_curve(in_surface, name=name, num_of_points=num_of_joints)

        # get num of spans curve
        list_of_cvs = mc.ls(rebuilt_curve + '.cv[*]', flatten=True)

        follicle_list = []

        for p in list_of_cvs:
            # Create follicle grp
            fol_p = name + '_follicles_custom_grp'
            if not (mc.objExists(fol_p)):
                fol_p = mc.createNode('transform', n=fol_p)

            # Create follicle transform and shape
            fol = mc.createNode('transform', n=(name + '_follicle'), p=fol_p)

            follicle_list.append(fol)

            fols = mc.createNode('follicle', p=fol, n=name + '_follicleShape')

            # Connect to current_lyr_geo
            mc.connectAttr(in_surface + '.worldMatrix[0]', fols + '.inputWorldMatrix')
            mc.connectAttr(in_surface + '.local', fols + '.inputSurface')
            mc.connectAttr(fols + '.outTranslate', fol + '.translate')
            # connect rotation if needed
            if self.rotation_on:
                mc.connectAttr(fols + '.outRotate', fol + '.rotate')
            # Create loc on point
            pos = mc.xform(p, q=1, t=1, ws=1)
            loc = mc.spaceLocator(n='pos_loc')[0]
            mc.move(pos[0], pos[1], pos[2], loc, rpr=1)
            # mc.parent(loc, in_surface)
            u_rng = mc.getAttr(in_surface + '.minMaxRangeU')
            v_rng = mc.getAttr(in_surface + '.minMaxRangeV')

            # Create node closestPointOnSurface
            point_surf = mc.createNode('closestPointOnSurface', n='tmp_closestPointOnSurface_1')
            mc.connectAttr(in_surface + '.local', point_surf + '.inputSurface')
            mc.connectAttr(loc + '.translate', point_surf + '.inPosition')

            # Get uv coords
            u = mc.getAttr(point_surf + '.u')
            v = mc.getAttr(point_surf + '.v')

            # Normalized uv's then set follicle paramenters
            norm_u = abs(u / u_rng[0][1])
            norm_v = abs(v / v_rng[0][1])

            if self.direction == 'v':
                mc.setAttr(fols + '.parameterV', norm_v)
                mc.setAttr(fols + '.parameterU', .5)
            else:
                mc.setAttr(fols + '.parameterU', norm_u)
                mc.setAttr(fols + '.parameterV', .5)

            mc.delete(point_surf, loc)

        # create joints inside follicles
        j_list = jnt_in_fol(follicle_list)

        # j_list = jnt_in_fol(follicle_list)
        fol_names = nm.rename_list(follicle_list, name + '_ribbon_layer', 'follicle_n')
        ribbon_jnt_list = nm.rename_list(j_list, name + '_ribbon_layer', '_skin')

        # Create top group
        # father_grp = trs.create_grp(name + '_custom_layer_grp')
        # mc.parent(fol_p, father_grp)

        # deleting curve
        mc.delete(rebuilt_curve, cvs_curve)

        return ribbon_jnt_list, fol_p

    def jnt_in_fol(self, in_fol):
        """
        Create a joint in each follicle
        return : list() or string
        """
        if isinstance(in_fol, list):
            j_list = list()
            for f in in_fol:
                mc.select(f, r=True)
                jnt = mc.joint()
                j_list.append(jnt)
            return j_list
        else:
            mc.select(in_fol, r=True)
            jnt = mc.joint()
            return jnt

    def parent_shape_ribbon(self, in_shape_obj, in_target, maintain_pos=False):
        '''
        Description:
            Panrent shape nodes to target objects.
            Dependencies:
                NONE
        '''
        mc.parent(in_shape_obj, in_target)
        mc.makeIdentity(in_shape_obj, apply=maintain_pos, t=True, r=True, s=True)
        mc.parent(in_shape_obj, w=True)

        shapes = []

        for s in mc.listRelatives(in_shape_obj, shapes=True):
            new_shape = mc.rename(s, in_target + 'Shape_1')
            shapes.append(new_shape)
        mc.parent(shapes, in_target, r=True, s=True)

        # Delete old grp
        mc.delete(in_shape_obj)

    def del_shapes(self, in_transform):
        shapes = mc.listRelatives(in_transform, s=True)
        if shapes:
            for s in shapes:
                mc.delete(s)

    def parent_shape(self, in_shape_obj, in_target, maintain_pos=False):
        '''
        Description:
            Panrent shape nodes to target objects.
            Dependencies:
                NONE
        '''
        mc.parent(in_shape_obj, in_target)
        mc.makeIdentity(in_shape_obj, apply=maintain_pos, t=True, r=True, s=True)
        mc.parent(in_shape_obj, w=True)

        shapes = []

        for s in mc.listRelatives(in_shape_obj, shapes=True):
            new_shape = mc.rename(s, in_target + '_shape_1')
            shapes.append(new_shape)
        mc.parent(shapes, in_target, r=True, s=True)

        # Delete old grp
        mc.delete(in_shape_obj)

    def add_ctrl_shapes_to_ribbon(self, in_control_lists,
                                  crvs_shapes=["cube", "sphere", "cube", "circleX", "circle"],
                                  crvs_colors=[13, 17, 14, 4, 24],
                                  **kwargs):
        """ adds control shapes to the list of ribbon joints """

        # getting the values of the passed key arguments
        c_t = ctrl_translation = kwargs.get('ctrl_translation')
        c_r = ctrl_rotation = kwargs.get('ctrl_rotation')
        c_s = ctrl_scale = kwargs.get('ctrl_scale')
        c_c = ctrl_color = kwargs.get('ctrl_color')
        c_o = ctrl_orientation = kwargs.get('ctrl_orientation')

        # list of the ribon layers joints
        for i, layer in enumerate(in_control_lists):

            for jnt in layer:

                if jnt:

                    shape = crvs_shapes[i]
                    color = crvs_colors[i]

                    if c_s:
                        if type(ctrl_scale) == type((1, 2)):
                            new_scale = (ctrl_scale[0] / (i + 1.0),
                                         ctrl_scale[1] / (i + 1.0),
                                         ctrl_scale[2] / (i + 1.0))
                        else:
                            new_scale = ctrl_scale / (i + 1.0)

                    ctrl_obj = ctgen.load_ctrl(ctrl_name=shape,
                                               ctrl_orientation=c_o,
                                               ctrl_rotation=c_r,
                                               ctrl_scale=new_scale * 10,  # tmp
                                               ctrl_color=color)

                    ctrl_crv = ctrl_obj.get_ctrl_name()
                    mc.delete(mc.pointConstraint(jnt, ctrl_crv))

                    ctrl_shape = ctrl_obj.get_shape_name()

                    mc.rename(ctrl_shape, jnt + "_shape")

                    self.parent_shape(ctrl_crv, jnt)

    def duplicate_curve(self, in_surface, name='', num_of_points=10, position=0.5):
        # in_surface = "spine_ribbon_plane_D_surf_D_driver"
        if not name:
            name = in_surface + "_crv"

        cvs_curve = mc.duplicateCurve('{}.v[{}]'.format(in_surface, position), ch=0, n=name)[0]

        # rebuild curve
        rebuilt_curve = mc.rebuildCurve(
            cvs_curve,
            ch=False,
            rpo=0,
            rt=0,
            end=1,
            kr=0,
            kcp=0,
            kep=1,
            kt=1,
            s=num_of_points,
            d=1,
            tol=0.01,
            n='rebuilt_curve'
        )[0]
        return rebuilt_curve, cvs_curve

    def change_surface_spans(self, in_surface, num_of_points=20, name="temp_surface"):
        """
        """
        curveA = duplicate_curve(in_surface, name='curveA', num_of_points=num_of_points, position=1)
        curveB = duplicate_curve(in_surface, name='curveB', num_of_points=num_of_points, position=0)

        loft_srf = mc.loft(curveA[0], curveB[0], ch=0, u=1, c=0, ar=0, d=1, ss=1, rn=0, po=0, rsn=True, n='tmp_guide_surf')[0]

        mc.delete(curveA, curveB)

        return loft_srf

    def set_name(self, name):
        self.name = name
        self.top_grp = "{}_rig_{}".format(self.name, sfx.group)
        self.driver_surfaces_grp = '{}_driver_{}_{}'.format(self.name, sfx.nurbsSurface, sfx.group)
        self.base_plane = '{}_source_{}'.format(self.name, sfx.nurbsSurface)


    def create_driver_surfaces(self, surface):
        """
        create driver surfaces by duplicating the highest resolution
        :param surface:
        :return:
        """
        self.driver_surface_list = []
        # get the final output surfaces with the same resolution
        for i in range(0, self.num_layers):
            driver_surface = mc.duplicate(surface, n='%s_%s_driver' % (surface, LETTERS[i]))[0]
            mc.parent(driver_surface, self.driver_surfaces_grp)
            self.driver_surface_list.append(driver_surface)


    def create_custom_lyr(self, jnt_layers_list, base_surf):
        # add layer
        in_bind_joints = jnt_layers_list[-1]

        out_surf = add_extra_custom_layer(base_surf, in_bind_joints)
        mc.parent(out_surf, w=1)

        ribbon_jnt_list, father_grp = self.add_follicles_to_custom_lyr(
            out_surf,
            num_of_joints=self.add_custom_lyr,
        )

        self.custom_lyr_dict["top_grp"] = father_grp
        self.custom_lyr_dict["jnt_list"] = ribbon_jnt_list
        self.custom_lyr_dict["surface"] = out_surf

        # return_dict["add_custom_lyr"] = ribbon_jnt_list
        self.return_dict["custom_lyr"] = self.custom_lyr_dict

    def set_position_locs(self):
        # Create matrix locators on all last layer positions
        last_surf = self.driver_surface_list[-1]

        if self.one_dimension:
            last_curve_tmp = mc.duplicateCurve(
                                                '{}.v[{}]'.format(last_surf, .5),
                                                ch=0,
                                                n="temp_last_curve"
                                                )[0]
            last_cvs = mc.ls(last_curve_tmp + ".cv[*]", fl=True)
        else:
            last_cvs = mc.ls(last_surf + ".cv[*]", fl=True)

        self.last_pos_list, last_transform_list = trs.create_objs_on_transforms(last_cvs, type='locator',
                                                                                     name=self.name)
        self.last_transform_list = last_transform_list[0]
        self.scale_locs_grp = last_transform_list[1]

        if self.one_dimension:
            mc.delete(last_curve_tmp)

    # def create_global_scale(self):
    #
    #     # matrix constraint start
    #     # create scale master loc : TODO : @HERE
    #     master_scale_loc = mc.spaceLocator(name=self.name + "_master_scale_loc")[0]
    #     master_scale_shape = mc.listRelatives(master_scale_loc, s=1)[0]
    #     parent_scale_loc = trs.create_offset_transform(master_scale_loc)
    #     mc.warning(parent_scale_loc + "    HERE __________________----------------------________________@@@@@@@@@@@@@@@@@@@@@@"+self.top_grp)

    def set_last_layer(self, driver_surf, bind_js, name=None):
        tmp_curve = mc.duplicateCurve(
            '{}.v[{}]'.format(driver_surf, .5),
            ch=0,
            n="LAST_temp_curve"
        )[0]

        w2s_geometry, w2s_geo, w2s_jointList, out_skin, weight_list = deformer.wire_to_skin(
            tmp_curve,
            geo=None,
            jnt_list=bind_js,
            name=name,
            divisions=1
        )  # [-1]
        mc.delete(tmp_curve)

        # matrix_nodes_list = skin.skin_weights_to_wmatrix(
        #     w2s_geometry,
        #     self.last_transform_list,
        #     driven_transform_list=None
        # )

        # # rename matrix_nodes_list:
        # temp_list = list()
        # for i, m in enumerate(matrix_nodes_list):
        #     new_name = pm.rename(m[0].name(), "{}_skn2mtx_out_{}_{}_mmx".format(name, LETTER, i))
        #     temp_list.append(new_name)

        # return matrix_nodes_list, w2s_geometry, weight_list
        return w2s_geometry, weight_list

    def set_one_d_ribbon(self, driver_surf, bind_js, next_surf, name=None):
        # weights from wire
        tmp_curve = mc.duplicateCurve(
            '{}.v[{}]'.format(driver_surf, .5),
            ch=0,
            n="temp_curve"
        )[0]

        w2s_geometry, w2s_geo, w2s_jointList, out_skin, weight_list = deformer.wire_to_skin(
            tmp_curve,
            geo=next_surf,
            jnt_list=bind_js,
            name=name,
            divisions=1
        )
        mc.delete(tmp_curve)
        return w2s_geometry, weight_list

    def setup_plane_ribbon(self, driver_surf, bind_js, next_surf):
        # weights from wire
        w2s_geometry = nurbs_weights_to_skin(driver_surf, next_surf, bind_js)

        return w2s_geometry, None


    def layered_scale_setup2(self, weight_list):

        # Connect out locs with connect_decompose_matrix()
        mmtx_list = list()
        for i, trs in enumerate(self.last_transform_list):
            mmtx_list.append(connect_decompose_matrix(trs)[1])
        # Connect scale matrices
        for lyr_idx, layer in enumerate(self.jnt_layers_list):
            # Create wam for the current layer. One for each output locator (number of out locators)
            wam_list = list()
            for loc_idx, loc in enumerate(self.last_transform_list):
                wam = mc.createNode("wtAddMatrix", n="{}_layer{}_{}_wam".format(self.name, LETTERS[lyr_idx], loc))
                wam_list.append(wam)
                mc.connectAttr("{}.matrixSum".format(wam), "{}.matrixIn[{}]".format(mmtx_list[loc_idx], lyr_idx), f=1)

            # Connect jnts to layer wams
            for jnt_idx, jnt in enumerate(layer):
                for i, wam in enumerate(wam_list):
                    wgt = weight_list[lyr_idx][jnt_idx][::2][i]
                    # listing every wam - this current will wgt A to input [0] in wan (from layer index (A=0)
                    cmtx = mc.createNode("composeMatrix", n="{}_layer{}_{}_cmtx".format(self.name, LETTERS[lyr_idx], jnt))
                    if self.blendShape:
                        driver = self.jnt_loc_dict[jnt]
                    else:
                        driver = jnt
                    mc.connectAttr("{}.scale".format(driver), "{}.inputScale".format(cmtx), f=1)
                    mc.connectAttr("{}.outputMatrix".format(cmtx), "{}.wtMatrix[{}].matrixIn".format(wam, jnt_idx), f=1)
                    # mc.setAttr(wam + ".wtMatrix[{}].weightIn".format(jnt_idx), wgt)

                    # add valeu to attr and connect it
                    s_attribute_type = "float"
                    s_attribute_name = "wgt{}{}{}Out".format(jnt_idx, LETTERS[lyr_idx], i)

                    mc.addAttr(driver, longName=s_attribute_name, attributeType=s_attribute_type)
                    mc.setAttr("{}.{}".format(driver, s_attribute_name), wgt)
                    mc.connectAttr("{}.{}".format(driver, s_attribute_name), "{}.wtMatrix[{}].weightIn".format(wam, jnt_idx))



    def create_joint_to_loc(self):
        """
        create locator to drive joint
        :param joint:
        :return:
        """
        # rgb color lists
        origin_value_list = [
            [1.0, 0.0024999999441206455, 0.02070000022649765],
            [1.0, 1.0, 0.0],
            [0.0, 0.5745000243186951, 1.0],
            [0.4625999927520752, 0.37959998846054077, 0.09009999781847],
            [0.1509000062942505, 0.580299973487854, 0.0],
            [1.0, 1.0, 0.0],
            [0.0, 1.0, 0.9516000151634216],
            [0.278, 0.098, 0.6269],

        ]
        target_value_list = [
            [1.0, 0.0, 0.0],
            [1.0, 0.98, 0.0],
            [0.0, 0.23160000145435333, 1.0],
            [0.11500000208616257, 0.44209998846054077, 0.0],
            [1.0, 0.05959999933838844, 0.0],
            [1.0, 0.0, 0.0],
            [0.278, 0.911, 0.6269],
        ]




        for i, lyr in enumerate(self.jnt_layers_list):
            lyr_locs = list()
            for joint in lyr:
                loc = mc.spaceLocator(n=joint.replace("_ctrl", "_sc_ctrl"))[0]
                # configure locshape for control transform
                locshape = mc.listRelatives(s=True)[0]
                scalevalue = self.width*.32/(i*.3+1) * 0.20
                mc.setAttr(locshape + ".localScaleX", 0)
                mc.setAttr(locshape + ".localScaleY", scalevalue)
                mc.setAttr(locshape + ".localScaleZ", scalevalue)

                mc.setAttr(locshape + ".localPositionY", scalevalue)

                # setup values and connect
                mc.parent(loc, joint)
                mc.makeIdentity(loc, apply=False, t=1, r=1, s=1)
                # make it a sibling
                parent = mc.listRelatives(joint, p=True)[0]
                mc.parent(loc, parent)
                for attr in "tr":
                    for axis in "xyz":
                        mc.connectAttr("{}.{}{}".format(loc, attr, axis), "{}.{}{}".format(joint, attr, axis))

                mc.connectAttr("{}.sx".format(loc), "{}.sx".format(joint))
                self.jnt_loc_dict[joint] = loc
                lyr_locs.append(loc)
            # lyr_locs set colors
            blend_color_override_rgb_values(lyr_locs, origin_value_list[i], target_value_list[i])

    def rename_ctrl_and_jnts(self):
        for jnt, loc in self.jnt_loc_dict.iteritems():
            name_holder_jnt = jnt
            name_holder_loc = loc
            tempname = mc.rename(jnt, "temp_name_just_bcause___")
            mc.rename(loc, name_holder_jnt)
            mc.rename(tempname, name_holder_jnt.replace(sfx.control, sfx.joint_skin))

    # setup
    def create_bind_joints(self):
        # check scale with dup bind_js :
        last_joints = self.jnt_layers_list[-1]
        bjlist = []
        for i, j in enumerate(last_joints):
            bind_j = mc.duplicate(j, po=1, n=j.replace("_ctrl", "_bind"))[0]
            bjlist.append(bind_j)
            for axis in "xyz":
                for at in "tr":
                    mc.connectAttr("{}.{}{}".format(j, at, axis), "{}.{}{}".format(bind_j, at, axis), f=True)
            mc.connectAttr("{}.sy".format(self.last_transform_list[i]), "{}.sy".format(bind_j, axis), f=True)
            mc.connectAttr("{}.sz".format(self.last_transform_list[i]), "{}.sz".format(bind_j, axis), f=True)

        self.bind_joint_list = bjlist


    # setup
    def replace_ctrl_jnts_with_locs(self):
        # check scale with dup bind_js :
        last_joints = self.jnt_layers_list[-1]
        bjlist = []
        for i, j in enumerate(last_joints):
            for i, j in enumerate(last_joints):
                bind_j = mc.duplicate(j, po=1, n=j.replace("_ctrl", "_bind"))[0]
                bjlist.append(bind_j)
                for axis in "xyz":
                    for at in "tr":
                        mc.connectAttr(
                            "{}.{}{}".format(j, at, axis),
                            "{}.{}{}".format(bind_j, at, axis),
                            f=True)
                mc.connectAttr("{}.sy".format(self.last_transform_list[i]),
                               "{}.sy".format(bind_j, axis), f=True)
                mc.connectAttr("{}.sz".format(self.last_transform_list[i]),
                               "{}.sz".format(bind_j, axis), f=True)

        self.bind_joint_list = bjlist


    # setup
    def create_bind_joints(self):
        # check scale with dup bind_js :
        last_joints = self.jnt_layers_list[-1]
        bjlist = []
        for i, j in enumerate(last_joints):
            bind_j = mc.duplicate(j, po=1, n=j.replace("_ctrl", "_bind"))[0]
            bjlist.append(bind_j)
            for axis in "xyz":
                for at in "tr":
                    mc.connectAttr(
                        "{}.{}{}".format(j, at, axis),
                        "{}.{}{}".format(bind_j, at, axis),
                        f=True)
            mc.connectAttr("{}.sy".format(self.last_transform_list[i]),
                           "{}.sy".format(bind_j, axis), f=True)
            mc.connectAttr("{}.sz".format(self.last_transform_list[i]),
                           "{}.sz".format(bind_j, axis), f=True)

        self.bind_joint_list = bjlist


    def create_global_scale(self):

        # matrix constraint start
        # create scale master loc
        master_scale_loc = mc.spaceLocator(name=self.name + "_scale_loc")[0]
        master_scale_shape = mc.listRelatives(master_scale_loc, s=1)[0]
        parent_scale_loc = trs.create_offset_transform(master_scale_loc)
        if self.curve_ribbon:
            transform_lists = self.curves_loc_lists
            scale_driven = self.driver_curve_list[0]

        else:
            transform_lists = self.all_follicles
            scale_driven = self.driver_surface_list[0]

        # connect scale to cluster
        cl = mc.cluster(scale_driven, n="scale_cluster")
        mc.connectAttr(cl[1]+".scale", master_scale_loc+".scale", f=1)
        # Connect scale - also rotation if curve ribbon
        for all_fol in transform_lists:
            for fol in all_fol:
                mc.connectAttr(master_scale_loc + ".scale", fol + ".scale", f=1)
                if self.curve_ribbon:
                    mc.connectAttr(cl[1] + ".rotate", fol + ".rotate", f=1)

        mc.parent(parent_scale_loc, cl, self.top_grp)

        self.return_dict.update({
            "scale_loc":master_scale_loc
        })


    def visual_reference(self, bind_mesh):
        # quick test
        dup_mesh = mc.duplicate(bind_mesh)[0]

        mel.eval("""
        polyExtrudeFacet -constructionHistory 1 -keepFacesTogether 1 -pvx 0 -pvy 0 -pvz 0 -divisions 1 -twist 0 -taper 1 -off 0 -thickness 0 -smoothingAngle 30 {0}.f[0:6300000];
        setAttr "polyExtrudeFace1.localTranslate" -type double3 0 0 10.1 ;
        select -r {0} ;
        xform -cpc;
        setAttr -l 0 "{0}.ty";
        setAttr "{0}.translateY" -0.05;
        delete -ch;
        """.format(dup_mesh))

        skin = mc.skinCluster(
            self.bind_joint_list,
            dup_mesh,
            dr=0,
            maximumInfluences=1,
            frontOfChain=1,
            toSelectedBones=1)

        for j in self.bind_joint_list:
            mc.setAttr(j+".v", 0)

        mc.select("*_ctrl")
        mc.select(dup_mesh, add=1)



    def plane_ribbon_setup(self):
        self.create_driver_planes(self.layer_geos[-1])
        # self.lyr_degree()
        # set up locs on curve
        # self.create_locs_on_curve()
        # blendshape curves
        blend_shape_chain(self.driver_plane_list)
        # copy skins
        copy_skins(self.smooth_skin_mesh_list, self.driver_surface_list[1:])
        # copy_skins(self.driver_surface_list, self.driver_curve_list)

        # set bind_pre_matrix
        for i, crv in enumerate(self.driver_surface_list[1:]):
            # get curve shape
            bind_pre_matrix(crv)

        # # parent from foll to curve locators
        # for jlist, loclist in zip(self.jnt_layers_list, self.curves_loc_lists):
        #     for jnt, loc in zip(jlist, loclist):
        #
        #         parent = mc.listRelatives(jnt, parent=True)[0]
        #         children = mc.listRelatives(parent, children=True, type="transform")
        #         grp = mc.group(children, n=parent.replace("follicle_n", sfx.group))
        #         mc.parent(grp, loc)

        # if self.out_curve:
        #     self.create_out_curve()


    def create_driver_planes(self, surface):
        planes_top_grp = mc.group(empty=True, name=self.name + "_planes_grp")
        mc.parent(planes_top_grp, self.top_grp)
        # get the final output surfaces with the same resolution
        for i in range(0, self.num_layers):
            driver_srf = self.create_last_plane(name='{}_{}_plane_driver'.format(surface, LETTERS[i]))
            self.driver_plane_list.append(driver_srf)

        mc.parent(self.driver_plane_list, planes_top_grp)

    def create_last_plane(self, name="surface"):
        # create surfaces
        u_points = self.lyr_density_u[self.num_layers-1]
        v_points = self.lyr_density_v[self.num_layers-1]

        srf = mc.nurbsPlane(
                            p=(0, 0, 0),
                            ax=self.axis,
                            width=self.width,
                            lengthRatio=self.length_ratio,
                            d=1,
                            u=u_points,
                            v=v_points,
                            ch=0,
                            n=name)[0]
        change_srf_degree(srf)
        
        return srf

        






    def curve_ribbon_setup(self):
        self.create_driver_curves(self.layer_geos[-1])
        self.lyr_degree()
        # set up locs on curve
        self.create_locs_on_curve()
        # blendshape curves
        blend_shape_chain(self.driver_curve_list)
        # copy skins
        copy_skins(self.smooth_skin_mesh_list, self.driver_curve_list[1:])
        # copy_skins(self.driver_surface_list, self.driver_curve_list)

        # set bind_pre_matrix
        for i, crv in enumerate(self.driver_curve_list[1:]):
            # get curve shape
            bind_pre_matrix(crv)

        # parent from foll to curve locators
        for jlist, loclist in zip(self.jnt_layers_list, self.curves_loc_lists):
            for jnt, loc in zip(jlist, loclist):

                parent = mc.listRelatives(jnt, parent=True)[0]
                children = mc.listRelatives(parent, children=True, type="transform")
                grp = mc.group(children, n=parent.replace("follicle_n", sfx.group))
                mc.parent(grp, loc)

        if self.out_curve:
            self.create_out_curve()

    def create_out_curve(self):
        # Duplicate curve
        self.output_curve = mc.duplicate(self.driver_curve_list[0], n=self.name + "_out_crv")[0]
        mc.skinCluster(self.jnt_layers_list[-1], self.output_curve, n=self.name + "_out_skc")

    def set_out_curve(self, value):
        self.out_curve = value

    def get_out_curve(self):
        return self.output_curve

    def set_degree(self, degree):
        self.degree = degree

    def lyr_degree(self):
        for c in self.driver_curve_list:
            # rebuild curve with given degree
            rebuilt_curve = mc.rebuildCurve(
                                            c,
                                            ch=False,
                                            rpo=1,
                                            rt=0,
                                            end=1,
                                            kr=0,
                                            kcp=1,
                                            kep=0,
                                            kt=0,
                                            d=self.degree,
                                            tol=0.01
                                            )[0]
            mc.delete(c, constructionHistory=True)


    def create_driver_curves(self, surface):
        """
        create driver curves by duplicating from the highest resolution
        :param surface:
        :return: curve list
        """
        crvs_top_grp = mc.group(empty=True, name=self.name + "_crvs_grp")
        mc.parent(crvs_top_grp, self.top_grp)
        # get the final output surfaces with the same resolution
        for i in range(0, self.num_layers):
            driver_crv = mc.duplicateCurve(surface + ".v[0.5]", ch=False, n='{}_{}_driver'.format(surface.replace(sfx.nurbsSurface, sfx.nurbsCurve), LETTERS[i]))[0]
            mc.parent(driver_crv, self.driver_surfaces_grp)
            self.driver_curve_list.append(driver_crv)

        mc.parent(self.driver_curve_list, crvs_top_grp)



    def create_locs_on_curve(self):
        locs_top_grp = mc.group(empty=True, name=self.name + "_crv_loc_grp")
        mc.parent(locs_top_grp, self.top_grp)

        # attach locators to curve list
        for i, (crv, jlist) in enumerate(zip(self.driver_curve_list, self.jnt_layers_list)):
            # attach to curve
            loc_list = list()
            for n, jnt in enumerate(jlist):
                loc = mc.spaceLocator(n='{}_{}_{}_loc'.format(self.name, LETTERS[i], n))[0]
                trs.snap_to_target(loc, jnt)
                # attach it
                attach_to_curve(crv, loc)
                loc_list.append(loc)

            # Append to list and cleanup
            grp = mc.createNode("transform", n="curve_locs_{}_{}".format(LETTERS[i], "grp"))
            mc.parent(loc_list, grp)
            # parent groups
            mc.parent(grp, locs_top_grp)

            self.curves_loc_lists.append(loc_list)

    def create_output_skinned_plane(self):
        # tmp_srf = mc.duplicate(self.driver_surface_list[-1])

        u_points = self.lyr_density_u[self.num_layers-1]*2
        v_points = self.lyr_density_v[self.num_layers-1]*2

        srf = mc.nurbsPlane(
            p=(0, 0, 0),
            ax=self.axis,
            width=self.width,
            lengthRatio=self.length_ratio,
            d=1,
            u=u_points,
            v=v_points,
            ch=0)[0]

        w2s_geometry = nurbs_weights_to_skin(self.driver_surface_list[-1], srf, self.bind_joint_list)
        mc.rename(w2s_geometry, self.name+"_auto_skinned_geo")



def attach_to_curve(curve, transform):
    # get curve shape
    shape = mc.listRelatives(curve, s=True)[0]
    # use nearestPointOnCurve to get parameter
    npoc = mc.createNode("nearestPointOnCurve")
    mc.connectAttr('%s.worldSpace' %shape, '%s.inputCurve' %npoc, f=True)

    # get position
    pos = mc.xform(transform, q=True, sp=True, ws=True)
    # Set stored transformation in nearestPointOnCurve inPosition
    mc.setAttr('{}.inPositionX'.format(npoc), pos[0])
    mc.setAttr('{}.inPositionY'.format(npoc), pos[1])
    mc.setAttr('{}.inPositionZ'.format(npoc), pos[2])

    # get param and delete nearestPointOnCurve
    param = mc.getAttr('{}.parameter'.format(npoc))
    mc.delete(npoc)

    # attach a new loc to curve with pointOnCurveInfo
    poci = mc.createNode('pointOnCurveInfo', n=transform + '_poci')
    mc.connectAttr('%s.worldSpace' %shape, '%s.inputCurve' %poci, f=True)

    # Connect and configure pointOnCurveInfo
    mc.connectAttr('%s.result.position' %poci, '%s.translate' %transform, f=True)
    mc.setAttr('%s.turnOnPercentage' %poci, 1)

    mc.setAttr('%s.parameter' %poci, param)

    return poci


def blend_shape_chain(shape_list):
    for x in range(0, len(shape_list) - 1):
        # Get vars
        cur_shape = shape_list[x]
        next_shape = shape_list[x + 1]
        # create blendshape to next shape
        blnd = mc.blendShape(
                            cur_shape,
                            next_shape,
                            frontOfChain=True,
                            n='layer_{}_blnd'.format(LETTERS[x]),
                            weight=[0,1.0]
                            )[0]
        # lock node
        targets = mc.listAttr(blnd + '.w', m=1)
        mc.setAttr(blnd + '.' + targets[0], lock=1)


def copy_skins(source_list, target_list):
    for s, t in zip(source_list, target_list):
        mc.select(s, t)
        try:
            # mc.warning(s + " ------------------ " + t)
            skin.copy_skin(s, t)
            # skin.copy_skin_to_nurbs(pm.PyNode(s), pm.PyNode(t))
        except:
            mc.warning("couldn't copy to :" + t)


def bind_pre_matrix(shape):
    # Connect bindPreMatrix
    bind_js = skin.get_bind_joints(shape)
    out_skin = skin.get_skin_cluster(shape)
    if out_skin:
        for i in range(len(bind_js)):
            if mc.attributeQuery('parentMatrixPath', node=bind_js[i], exists=True):
                mtx_jnt = mc.listConnections(bind_js[i] + '.parentMatrixPath')
                mc.connectAttr('%s.parentInverseMatrix' % mtx_jnt[0], out_skin + '.bindPreMatrix[%d]' % i)
            else:
                mc.connectAttr('%s.parentInverseMatrix' % bind_js[i], out_skin + '.bindPreMatrix[%d]' % i)



# Start functions
def get_dag_path(node=None):
    """
    Get dag path from given node
    :param node:
    :return:
        <class 'maya.OpenMaya.MDagPath'>
    Usage :
        >>> sel_inc_mtx = get_dag_path(mc.ls(sl=1)[0]).inclusiveMatrix()

    """
    sl = om.MSelectionList()
    sl.add(node)
    d = om.MDagPath()
    sl.getDagPath(0, d)
    return d


def get_local_offset(parent, child):
    """
    # Get offset matrix by multiplying CHILD's worldMatrix x PARENT's worldInverseMatrix
    :param parent:
    :param child:
    :return: Local Offset matrix or delta
    """
    parent_world_matrix = get_dag_path(parent).inclusiveMatrix()
    child_world_matrix = get_dag_path(child).inclusiveMatrix()

    return child_world_matrix * parent_world_matrix.inverse()


def connect_decompose_matrix(target_transform,
                             in_matrix_attr=None,
                             translate=True,
                             rotate=True,
                             scale=True,
                             shear=True,
                             name=None):
    """
    Connect matrix output attribute to a decompose matrix and connect to target :
    >>> target_transform = "mc.polyCube(ch=0, n="child_cube")[0]
    >>> res = connect_decompose_matrix("test_scale_MASTER_mmtx.matrixSum",
    >>>                                target_transform,
    >>>                                translate=1,
    >>>                                rotate=0,
    >>>                                scale=1,
    >>>                                shear=1)
    """
    # set name if it's None
    if not name:
        name = target_transform + "_dmtx"

    # Create node decomposeMatrix
    decompMatrix = mc.createNode("decomposeMatrix", n=name)
    multMatrix = mc.createNode("multMatrix", n=name + "_multMatrix")
    # wam = mc.createNode("wtAddMatrix", n=name + "_wtAddMatrix")

    # Set matrix value
    # mtx = mc.getAttr(target_transform + ".matrix")
    # mc.setAttr(wam + ".wtMatrix[0].matrixIn", mtx, type="matrix")
    # mc.setAttr(wam + ".wtMatrix[0].weightIn", 1)


    # Connect input matrix if object was passed3
    if in_matrix_attr:
        if not "." in in_matrix_attr:
            mc.error(in_matrix_attr + " is not and attribute. Ex. locator_pos.parentInverseMatrix")
        in_object =  in_matrix_attr.split(".")[0]
        mc.connectAttr(in_matrix_attr, decompMatrix + ".inputMatrix")


    attr_list = ["Translate", "Rotate", "Scale", "Shear"]
    on_off_list = [translate, rotate, scale, shear]

    # connect decompMatrix to target_transform
    for attr, state in zip(attr_list, on_off_list):
        if state:
            if attr == "Shear":
                for axis, saxis in zip("XYZ", ["XY", "XZ", "YZ"]):
                    print saxis, axis
                    mc.connectAttr( "{}.output{}.output{}{}".format(decompMatrix, attr, attr, axis),
                                    "{}.{}{}".format(target_transform, attr.lower(), saxis), f=1)
            else:
                for axis in "XYZ":
                    mc.connectAttr( "{}.output{}.output{}{}".format(decompMatrix, attr, attr, axis),
                                    "{}.{}{}".format(target_transform, attr.lower(), axis), f=1)



    # mc.connectAttr( "{}.matrixSum".format(wam), "{}.inputMatrix".format(decompMatrix))
    mc.connectAttr( "{}.matrixSum".format(multMatrix), "{}.inputMatrix".format(decompMatrix))


    return decompMatrix, multMatrix




def get_valid_orig_shape(obj):

    shapes = mc.listRelatives(obj, s=1)

    intermediates = []
    for sh in shapes:
        if mc.getAttr(sh+'.io'): #intermediateObject
            if mc.listConnections(sh):
                intermediates.append(sh)
    if intermediates:
        if len(intermediates)>1:
            mc.warning("There are {} intermidiate shapes in {}".format(len(intermediates), obj))
        return intermediates[0]
    else:
        return None



def reset_skin_cluster(geo_list):
    for each in geo_list:
        skinClusterDef = mc.ls(mc.listHistory(each, pdo=True),type='skinCluster')

        if skinClusterDef:
            infs = mc.listConnections( skinClusterDef[0] + '.matrix' )

            for i, inf in enumerate( infs ):

                m = mc.getAttr( inf + '.worldInverseMatrix' )
                mc.setAttr(
                    skinClusterDef[0] + '.bindPreMatrix[' + str(i) + ']',
                    m[0], m[1], m[2], m[3],
                    m[4], m[5], m[6], m[7],
                    m[8], m[9], m[10], m[11],
                    m[12], m[13], m[14], m[15],
                    typ= 'matrix' )


''' Blend color override RGB values 31/03/2016 ''' ##########################################################
#######################################################################################################
def blend_color_override_rgb_values(inManipList, originValueList, targetValueList):
    """
    Blend color override RGB values
    date : 31/03/2016
    :param inManipList:
    :param originValueList:
    :param targetValueList:
    :return:
    """
    factorList = []
    for oriV, trgV in zip(originValueList, targetValueList) :
        addFactor = (oriV - trgV)/len(inManipList)
        factorList.append(abs(addFactor))

    stepR = originValueList[0]
    stepG = originValueList[1]
    stepB = originValueList[2]

    for i, s in enumerate(inManipList):#pass

        #Get shape node
        shape = mc.listRelatives(s, s=1)[0]
        # Enable overrides
        mc.setAttr(shape + ".overrideEnabled", 1)
        mc.setAttr(shape + ".overrideRGBColors", 1)

        if i == 0:
            stepR += factorList[0]
            stepG += factorList[1]
            stepB += factorList[2]
            mc.setAttr(shape + ".overrideColorR", originValueList[0])
            mc.setAttr(shape + ".overrideColorG", originValueList[1])
            mc.setAttr(shape + ".overrideColorB", originValueList[2])
        elif i == len(inManipList)-1:
            mc.setAttr(shape + ".overrideColorR", targetValueList[0])
            mc.setAttr(shape + ".overrideColorG", targetValueList[1])
            mc.setAttr(shape + ".overrideColorB", targetValueList[2])
        else:

            signR = 1
            signG = 1
            signB = 1

            if originValueList[0] > targetValueList[0]:
                signR = -1
            if originValueList[1] > targetValueList[1]:
                signG = -1
            if originValueList[2] > targetValueList[2]:
                signB = -1

            stepR += factorList[0] * signR
            stepG += factorList[1] * signG
            stepB += factorList[2] * signB

            mc.setAttr(shape + ".overrideColorR", stepR)
            mc.setAttr(shape + ".overrideColorG", stepG)
            mc.setAttr(shape + ".overrideColorB", stepB)




# start plane functions
def change_srf_degree(surface, degree_u=2, degree_v=2):
    mc.rebuildSurface(
                        surface,
                        constructionHistory=0,
                        replaceOriginal=1,
                        endKnots=1,
                        keepRange=0,
                        keepControlPoints=1,
                        keepCorners=0,
                        degreeU=degree_u,
                        degreeV=degree_v,
                        tolerance=0,
                        fitRebuild=0,
                        direction=2
                        )
    mc.delete(surface, ch=True)


def get_data(in_srf):
    # Get surface data
    shape = mc.listRelatives(in_srf, shapes=True)[0]
    spans_u, spans_v = mc.getAttr('{}.spansUV'.format(shape))[0]
    degree_u, degree_v = mc.getAttr('{}.degreeUV'.format(shape))[0]
    return {
        "spans": [spans_u, spans_v],
        "degree":[degree_u, degree_v],
        "points":[int(spans_u+degree_u), int(spans_v+degree_v)]
    }

def nurbs_weights_to_skin(driver_srf, rider_srf, joint_list):
    # driver surface
    uCount, vCount = get_data(driver_srf)["points"]

    # Get every world matrix in nested cvMatrices list
    cvMatrices = []
    n=0
    for i in range(uCount):
        row = []
        for j in range(vCount):
            cv = joint_list[n]
            n+=1
            row.append('%s.worldMatrix[0]' % cv)
        cvMatrices.append(row)

    # Get weights for each surface component
    pCountU, pCountV = get_data(rider_srf)["points"]

    # set dict clean
    weights_dict = {}
    for joint in joint_list:
        weights_dict[joint] = list()
    degree = 3
    # Get them weights
    for jnt in joint_list:
        for j in range(pCountV):
            for i in range(pCountU):
                u = i / (float(pCountU) - 1)
                v = j / (float(pCountV) - 1)
                pointMatrixWeights = matrix_spline.pointOnSurfaceWeights(cvMatrices, u, v, degree=degree)
                cur_jnts_list = []
                for m in pointMatrixWeights:cur_jnts_list.append(m[0].split(".")[0])
                for each in pointMatrixWeights:
                    j_weighted = each[0].split(".")[0]
                    if jnt in cur_jnts_list:
                        if jnt==j_weighted:
                            weights_dict[jnt].append(each[1])
                    else:
                        weights_dict[jnt].append(0.0)
                        cur_jnts_list.append(jnt)

    # Creat weight mesh
    rider_geo = mc.nurbsToPoly(rider_srf, f=3 , pt=1, mnd=True, n="nurbs_weights_to_skin_geo" )[0]

    # Apply weights
    out_skin = mc.skinCluster(
        joint_list,
        rider_geo,
        dr=4.5,
        maximumInfluences=1,
        frontOfChain=0,
        toSelectedBones=1,
        n='out_mesh_skc'
    )
    # set weights to mesh
    vtxs = mc.ls(rider_geo + '.vtx[*]', fl=1)
    x=0
    for i, j in enumerate(joint_list):
        for y, dis in enumerate(weights_dict[j]):
            norm_value = dis
            mc.skinPercent(
                out_skin[0],
                rider_geo + '.' + vtxs[y].split('.')[1],
                transformValue=[(j, norm_value)]
            )
            mc.setAttr(j + '.liw', 1)
    for j in joint_list: mc.setAttr(j + '.liw', 0)

    return rider_geo

from kmd.lib.ctrl_class import Ctrl_class
from kmd.lib.ctrl import ctrl_class

def set_control_shapes():
    ctrl_shapes = ["cube", "sphere", "cube", "sphere"]
    for i, ct_list in enumerate(ribbon_ctrls):
        shape=ctrl_shapes[i]
        for c in ct_list:
            ctrl_dict = Ctrl_class().create_ctrl(shape, transform=True, register_loc=None)
            ctrl = ctrl_dict.get("ctrl_name")
            ctrl_class.parentShape(ctrl, c, maintainPos=False)
            # Color
            # scale

def lock_and_hide_loc_shapes(locator_list):
    # lock and hide loc shapes
    for loc in locator_list:
        loc_shape = mc.listRelatives(loc, type="locator")
        if loc_shape:
            for l in loc_shape:
                mc.setAttr(l + ".v", lock=False)
                mc.setAttr(l + ".v", 0, lock=True)


